/*
Запустите код. Затем посмотрите внимательно на звёзды и скажите: сколько горутин запускалось, а также расскажите о дальнейшей их судьбе.
*/
/*
Ответ:
Всего запускается 3 горутины: 1 главная горутина и 2 дочерних горутины
1-я дочерняя горутина через инструкцию select "ловит" данные из канала stop и из канала ch
Т.к. есть ветвь default то select не блокируется и горутина постоянно проверяет пришли ли данные с каналов
2-я дочерняя горутина "тормозная" в ветке default ждет 1 сек. и если канал ch не нулевой то отправляет в него значение i
Главня горутина после запуска 2-х дочерних горутин ждет 5 сек
В это время 1-я скоростная горутина как только что то появляется в канале ch сразу выводит его значение на экран (1,2,3,4)
А 2-я "тормозная" в ветке default ждет 1 сек потом помещает значение i в канал ch и блокируется пока кто-то не прочитает ch
Главная горутина, по истечении 5 сек отправляет первую пустую структуру в канал stop, ее тут же успевает прочитать
1-я дочерня горутина и завершиться
Потом отправляется вторая пустая структура в stop
И сколько бы не длилась пауза после этого, 2-я дочерняя горутина в это время будет выполнять код в ветке default: ждать 1сек,
записывать значение i в канал ch и блокироваться пока его не прочитают
И после вывода сообщения "завершение работы главной горутины" завершается главная горутина,
а в месте сней и все дочерние горутины которые не успели выполнить свой код

Если в коде после первого stop добавить чтение из ch, то вторая горутина тоже завершится с сообщением
*/
package main

import (
	"fmt"
	"time"
)

func main() {

	ch := make(chan int)
	stop := make(chan struct{}, 2)
	go func() {
	OUT:
		for {
			select {
			case <-stop:
				break OUT
			case v, ok := <-ch:
				if !ok {
					break OUT
				}
				fmt.Println(v)

			default:
				continue
			}
		}
		fmt.Println("завершение работы горутины_1")
	}()
	go func() {
		var i int
	OUT:
		for {
			i++
			//fmt.Println("Увеличила i = ", i)
			select {
			case <-stop:
				break OUT
			default:
				//fmt.Println("Жду 1 сек")
				time.Sleep(time.Second)
				if ch == nil {
					continue
				}
				//fmt.Println("Помещаю i в канал", i)
				ch <- i
				//fmt.Println("Поместила i в канал", i)
			}
		}
		fmt.Println("завершение работы горутины_2")
	}()
	time.Sleep(5 * time.Second)
	stop <- struct{}{}
	// <-ch
	stop <- struct{}{}
	time.Sleep(2 * time.Second)
	fmt.Println("завершение работы главной горутины")
}
